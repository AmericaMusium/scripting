/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <engine>
#include <fakemeta>
#include <fakemeta_util>
#include <fun>
#include <dodx>
#include <dodfun>
#include <dodconst>
#include <dodstats>
#include <hamsandwich>


#define PLUGIN "DOD_ANTITROOPMINE"
#define VERSION "12feb2022"
#define AUTHOR "[America][TheVaskov]"




#define TRIPMINE_MAXALL 64
#define TRIPMINE_MAXHAVE 2
#define TRIPMINE_SETDIST 150.0
#define TRIPMINE_RADDAM 200.0
#define TRIPMINE_DAMAGE 44.0
new const gentClassname[] = "tripmine" //Classname нашего entity

new const gentModel[] = "models/tnt_tripmine.mdl" // Модель
new const gentSpriteExplode[] = "sprites/explosion1.spr" //Спрайт взрыва
new const gentSpriteSmoke[] = "sprites/puff.spr" //Спрайт дыма
new gent_Sprite[3] //Сюда запишем индексы спрайтов


new g_mine_limit[33]
new g_mine_owner[2048]
new g_maxmines 
new g_MessageFade, gMsgDeathMsg, gMsgFrags


// new p_friendlyfire


public plugin_init()
{
	register_plugin(PLUGIN, VERSION, AUTHOR)
	register_touch(gentClassname, "player", "EntityTouch") //Создаем событие прикосновение с entity
	// register_forward(FM_Touch, "EntityTouch", 1)
	// register_think(gentClassname, "EntityThink") //Создаем событие действий entity
	
	
	// register_clcmd("say /entity", "StartCreate") //Команда для создание
	// register_clcmd("say /delete", "DeleteAllMines") //Команда для создание	
	
	
	
	register_event("HLTV", "DeleteAllMines", "a", "1=0", "2=0")
	
	g_MessageFade = get_user_msgid("ScreenFade") //  регистрирует глоб месседж
	gMsgDeathMsg = get_user_msgid("DeathMsg")
	gMsgFrags = get_user_msgid("Frags")
	
	
	RegisterHam(Ham_TakeDamage, "info_target", "fw_takedamage");
	register_forward(FM_CmdStart,"anttroop_button") // регистрируем форвард для открытия меню по кнопке е
	
	
	// p_friendlyfire = get_cvar_pointer("mp_friendlyfire")
}
public anttroop_button(id, uc_handle)// функция, которая реализует открытие меню на кнопку е
{
static Button, OldButtons;
Button = get_uc(uc_handle, UC_Buttons);
OldButtons = pev(id, pev_oldbuttons);

if((Button & IN_USE) && !(OldButtons & IN_USE))
	StartCreate(id)
	
}


public plugin_precache()
{
	precache_model( gentModel ) //Передаем в прекаш модель
	gent_Sprite[1] = precache_model( gentSpriteExplode ) //Передаем в прекаш спрайт взрыва
	gent_Sprite[2] = precache_model( gentSpriteSmoke ) //Передаем в прекаш спрайт дыма
} 

public DeleteAllMines(){
	
	new i4Entity  = engfunc(EngFunc_FindEntityByString, 0, "model", gentModel) // cоздаём переменную присваем номер через функцию
	while(i4Entity != 0){
		/// пока энтити не равна нолю и если она больше то удаляем
		if(i4Entity > 0){
			remove_entity(i4Entity)
			// client_print(0,print_chat,"Removed %d", i4Entity)
			g_maxmines = 0
		}
		
		i4Entity = engfunc(EngFunc_FindEntityByString, 0, "model", gentModel)
		if(i4Entity == 0) {
			// client_print(0,print_chat,"Removed alll")
			
			g_maxmines = 0
			i4Entity = 0
			break
			/// а вот она теперь равна нолю
		}
	}	
	
	for(new id = 0 ; id < get_maxplayers() ; id++){
		g_mine_limit[id] = 0
	}
}		

public StartCreate(id)
{
	if(is_user_connected(id) && is_user_alive(id)){
		new iOrigin[3] //Создаем массив для хранение координат
		new iOrigin1[3] // игрока ориджэин
		get_user_origin(id, iOrigin, 3) //Получаем координаты куда смотрит игрок
		get_user_origin(id, iOrigin1, 0) // координаты игрока
		
		new Float:fOrigin[3] //Создаем массив для float коодинат
		IVecFVec(iOrigin, fOrigin) //Конвертируем координаты в дробные \ берём точку трассировки зрения
		
		// new i4Entity = engfunc(EngFunc_CreateNamedEntity,engfunc(EngFunc_AllocString,"info_target"))
		new i4Entity = create_entity("info_target")	// создаём Энтити
		set_pev(i4Entity, pev_origin, fOrigin) //Присваиваем координаты точки зрения	
		
		
		if(!pev_valid(i4Entity)) 
			{//Проверяем сущетсвует ли, если нет
		return PLUGIN_HANDLED //Заканчиваем. Дальше нам делать нечего
	}
	
	set_pev(i4Entity, pev_health, 1.0);
	set_pev(i4Entity, pev_takedamage, DAMAGE_YES);
	set_pev(i4Entity, pev_classname, gentClassname) //Присваиваем Classname
	set_pev(i4Entity, pev_solid, SOLID_BBOX) //Делаем его непроходимым
	set_pev(i4Entity, pev_movetype, MOVETYPE_NONE) //Не задаем тип движения, во всяком случаи пока
	// set_pev(i4Entity, pev_sequence, 0) //Выставляем № анимации при создании
	// set_pev(i4Entity, pev_framerate, 1.0) //Выставляем скорость анимации
	
	new units = get_entity_distance(id,i4Entity) // берём дистанцию между хозяином и миной
	// client_print(id,print_chat,"Distance to mine %d units", units) // вывод информации
	
	if(units > TRIPMINE_SETDIST || g_maxmines >= TRIPMINE_MAXALL || g_mine_limit[id] >= TRIPMINE_MAXHAVE)  // если расстоняние более 150 , или колво макс мин больше то удаляем
	{ 
		remove_entity(i4Entity)
		// client_print(id,print_chat,"You can not set mine: Distance: %d / %f | Actived mines on ground %d / %d ",units, TRIPMINE_SETDIST, g_mine_limit[id], TRIPMINE_MAXHAVE )
		
	}
	else{
		/// ну а если не больше 150 то выполняем этот код
		
		g_maxmines++
		g_mine_limit[id]++
		g_mine_owner[i4Entity] = id
		
		// set_pev(i4Entity, pev_nextthink, get_gametime() + 1.0) //Создаем запуск think
		
		emit_sound(id,CHAN_VOICE,"weapons/bazookareloadshovehome.wav",0.8,ATTN_NORM,0,PITCH_NORM + random_num(-30, -20)) // звук установки
		engfunc(EngFunc_SetModel, i4Entity, gentModel) //Присваиваем модель
		engfunc(EngFunc_SetSize, i4Entity, Float:{-6.0, -6.0, -3.0}, Float:{6.0, 6.0, 3.0}) //Создаем бокс вокруг entity( для прикосновения и не только )
		
	}
}
return PLUGIN_HANDLED
} 

public EntityTouch(i4Entity, id)
{

/// касание между мной и миной

if(!pev_valid(i4Entity)) //Проверяем сущетсвует ли, если нет
	return FMRES_IGNORED


new Float:fOriginE[3] //Создаем массив для float координат entity
pev(i4Entity, pev_origin, fOriginE) //Получаем координаты entity

new iPlayers[32] //Создаем массив для хранение индексов игроков
new iPlayer, iNum //Для записи кол-во игроков и отдельный взятый индекс

get_players(iPlayers, iNum, "ach") //Получаем игроков, исключая мертвых, ботов и hltv


for(new i; i < iNum; i++) //Создаем цикл по всем игрокам
{
	iPlayer = iPlayers[i] //Для удобства записываем отдельно
	
	new Float:fOriginP[3] //Создаем массив для float координат игрока
	pev(iPlayer, pev_origin, fOriginP) //Получаем координаты игрока
	
	new Float:fDistance //Создаем массив для хранение дистанции
	fDistance = get_distance_f(fOriginP, fOriginE) //Получаем дистанцию между игроком и entity
	
	if(fDistance < TRIPMINE_RADDAM) //Если дистанция < 300.0
	{	
		new current_health = pev(iPlayer,pev_health)
		
		new Float:damagetripmine = TRIPMINE_RADDAM - fDistance
		
		current_health = current_health - damagetripmine - TRIPMINE_DAMAGE
		if(current_health >= 1.0){
			set_pev(iPlayer,pev_health,current_health)
		}
		if(current_health <= 1.0){
			new deathcount =  dod_get_pl_deaths(iPlayer)
			deathcount++
			dod_set_pl_deaths(iPlayer, deathcount, 1)
			user_silentkill(iPlayer)
			
			message_begin(MSG_ALL,gMsgDeathMsg,{0,0,0},0)
			write_byte(g_mine_owner[i4Entity]) // killer
			write_byte(iPlayer) // victim
			write_byte(42)  // 42 is smash
			message_end()
			
			
		}
		
		
		message_begin(MSG_BROADCAST,SVC_TEMPENTITY) //Создаем сообщение
		write_byte(TE_EXPLOSION) //Индекс сообщение(взрыва)
		engfunc(EngFunc_WriteCoord, fOriginE[0]) //Координата x
		engfunc(EngFunc_WriteCoord, fOriginE[1]) //Координата y
		engfunc(EngFunc_WriteCoord, fOriginE[2] + 30.0) //Координата z
		write_short(gent_Sprite[1]) //Индекс спрайта взрыва
		write_byte(10) //Размер спрайта
		write_byte(15) //Скорость анимации
		write_byte(0) //Флаги
		message_end() //Конец сообщение
		
		message_begin(MSG_BROADCAST,SVC_TEMPENTITY)//Создаем сообщение
		write_byte(TE_SMOKE) //Индекс сообщение(дым)
		engfunc(EngFunc_WriteCoord, fOriginE[0]) //Координата x
		engfunc(EngFunc_WriteCoord, fOriginE[1]) //Координата y
		engfunc(EngFunc_WriteCoord, fOriginE[2] + 50.0) //Координата x
		write_short(gent_Sprite[2]) //Индекс спрайта дыма
		write_byte(25) //Размер спрайта
		write_byte(10) //Скорость анимации
		message_end() //Конец сообщение
		
		
		message_begin(MSG_BROADCAST, SVC_TEMPENTITY);
		write_byte(TE_WORLDDECAL);
		engfunc(EngFunc_WriteCoord, fOriginE[0]);
		engfunc(EngFunc_WriteCoord, fOriginE[1]);
		engfunc(EngFunc_WriteCoord, fOriginE[2]);
		write_byte(60);
		message_end();
		
		red_flash(iPlayer)
		
		
	}
	
	
	
	
}

g_mine_limit[(g_mine_owner[i4Entity])] --
g_maxmines--

new fragcount = dod_get_user_kills(g_mine_owner[i4Entity])
fragcount++
dod_set_user_kills(g_mine_owner[i4Entity], fragcount, 1)
if(g_maxmines<1) g_maxmines=0

remove_entity(i4Entity)

return FMRES_IGNORED   // было так
// return FMRES_SUPERCEDE
} 

///////////////////////////////////////////////


stock red_flash(id)
{

message_begin(MSG_ONE_UNRELIABLE, g_MessageFade , {0,0,0}, id)
write_short(1<<10)
write_short(1<<10)
write_short(0x0001)
write_byte(240)
write_byte(10) 
write_byte(10) 
write_byte(50)
message_end() 	

/*
new gmsgShake = get_user_msgid("ScreenShake")
message_begin(MSG_ONE, gmsgShake, {0,0,0}, id)
write_short(255<<14) //ammount
write_short(10<<14) //lasts this long
write_short(255<<14) //frequency
message_end()
*/
}

//////// 

stock bool:is_ent_barney(i4Entity)      
{
if(pev_valid(i4Entity))      
{
	static classname[32];
	pev(i4Entity, pev_classname, classname, 31);
	if(equal(classname, "tripmine"))      
		return true;
}
return false;
}

public fw_takedamage(i4Entity, idinflictor, idattacker, Float:damage, damagebits) 
{
if(!is_ent_barney(i4Entity)) 
	return HAM_IGNORED;


new Float:fOriginE[3] //Создаем массив для float координат
pev(i4Entity, pev_origin, fOriginE) //Получаем координаты entity

	///////// EXPLOSSION 
	
	message_begin(MSG_BROADCAST,SVC_TEMPENTITY) //Создаем сообщение
	write_byte(TE_EXPLOSION) //Индекс сообщение(взрыва)
	engfunc(EngFunc_WriteCoord, fOriginE[0]) //Координата x
	engfunc(EngFunc_WriteCoord, fOriginE[1]) //Координата y
	engfunc(EngFunc_WriteCoord, fOriginE[2]) //Координата z
	write_short(gent_Sprite[1]) //Индекс спрайта взрыва
	write_byte(10) //Размер спрайта
	write_byte(15) //Скорость анимации
	write_byte(0) //Флаги
	message_end() //Конец сообщение
	
	message_begin(MSG_BROADCAST,SVC_TEMPENTITY)//Создаем сообщение
	write_byte(TE_SMOKE) //Индекс сообщение(дым)
	engfunc(EngFunc_WriteCoord, fOriginE[0]) //Координата x
	engfunc(EngFunc_WriteCoord, fOriginE[1]) //Координата y
	engfunc(EngFunc_WriteCoord, fOriginE[2] + 50.0) //Координата x
	write_short(gent_Sprite[2]) //Индекс спрайта дыма
	write_byte(15) //Размер спрайта
	write_byte(15) //Скорость анимации
	message_end() //Конец сообщение
	
	
	message_begin(MSG_BROADCAST, SVC_TEMPENTITY);
	write_byte(TE_WORLDDECAL);
	engfunc(EngFunc_WriteCoord, fOriginE[0]);
	engfunc(EngFunc_WriteCoord, fOriginE[1]);
	engfunc(EngFunc_WriteCoord, fOriginE[2]);
	write_byte(60);
	message_end();
	
	
	
	
	
	g_mine_limit[(g_mine_owner[i4Entity])] --
	g_maxmines--
	if(g_mine_limit[(g_mine_owner[i4Entity])] <= 0) g_mine_limit[(g_mine_owner[i4Entity])] = 0
	if(g_maxmines <= 0) g_maxmines = 0
	
	// if(pev_valid(i4Entity))     remove_entity( i4Entity )
	// radius_damage(fOriginE, 1, 20)
	return PLUGIN_HANDLED 
	
}

/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ deff0{\\ fonttbl{\\ f0\\ fnil Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang1049\\ f0\\ fs16 \n\\ par }
*/
