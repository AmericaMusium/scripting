/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <engine>
#include <fakemeta>
#include <fakemeta_util>
#include <fun>
#include <dodx>
#include <dodfun>
#include <dodconst>
#include <dodstats>
#include <hamsandwich>


#define PLUGIN "DOD WALLS"
#define VERSION "19112022"
#define AUTHOR "[America][TheVaskov]"


#define GMORTAR_MAXALL 64
#define GMORTAR_MAXHAVE 5
#define GMORTAR_SETDIST 250.0
#define GMORTAR_RADDAM 200.0
#define GMORTAR_DAMAGE 44.0


new const g_gmcname[] = "groundmortar" //Classname нашего entity

new const g_gmmdl[] = "models/mapmodels/sandbags.mdl" // Модель
new const gentSpriteExplode[] = "sprites/explosion1.spr" //Спрайт взрыва
new const gentSpriteSmoke[] = "sprites/puff.spr" //Спрайт дыма
new gent_Sprite[3] //Сюда запишем индексы спрайтов

new g_gm_limit[33]
new g_gm_owner[2048]
new g_maxgm
new g_MessageFade, gMsgDeathMsg, gMsgFrags
new bool: g_player_accept[33];

// new p_friendlyfire
public plugin_init()
{
	register_plugin(PLUGIN, VERSION, AUTHOR)
	// register_touch(g_gmcname, "player", "EntityTouch") //Создаем событие прикосновение с entity
	// register_forward(FM_Touch, "EntityTouch", 1)
	// register_think(g_gmcname, "EntityThink") //Создаем событие действий entity
	
	
	register_clcmd("say wall", "object_create") //Команда для создание
	// register_clcmd("say /delete", "DeleteAllMines") //Команда для создание	
	
	
	register_event("CurWeapon","object_accept","be","1=1")
	register_event("HLTV", "Del_all_gmortars", "a", "1=0", "2=0")
	
	g_MessageFade = get_user_msgid("ScreenFade") //  регистрирует глоб месседж
	gMsgDeathMsg = get_user_msgid("DeathMsg")
	gMsgFrags = get_user_msgid("Frags")
	
	
	// p_friendlyfire = get_cvar_pointer("mp_friendlyfire")
}

public plugin_precache()
{
	precache_model( g_gmmdl ) //Передаем в прекаш модель
	gent_Sprite[1] = precache_model( gentSpriteExplode ) //Передаем в прекаш спрайт взрыва
	gent_Sprite[2] = precache_model( gentSpriteSmoke ) //Передаем в прекаш спрайт дыма
} 

public Del_all_gmortars()
{
	
	new object  = engfunc(EngFunc_FindEntityByString, 0, "model", g_gmmdl) // cоздаём переменную присваем номер через функцию
	while(object != 0){
		/// пока энтити не равна нолю и если она больше то удаляем
		if(object > 0){
			remove_entity(object)
			// client_print(0,print_chat,"Removed %d", object)
			g_maxgm= 0
		}
		
		object = engfunc(EngFunc_FindEntityByString, 0, "model", g_gmmdl)
		if(object == 0) {
			// client_print(0,print_chat,"Removed alll")
			
			g_maxgm= 0
			object = 0
			break
			/// а вот она теперь равна нолю
		}
	}	
	
	for(new id = 0 ; id < get_maxplayers() ; id++){
		g_gm_limit[id] = 0
	}
}		

public object_create(id)
{   
    if(!is_user_connected(id) || !is_user_alive(id))
        return 0;
	else if(is_user_connected(id) && is_user_alive(id))
    {
		new object = create_entity("info_target")	// создаём Энтити

	    g_player_accept[id] = false
        set_pev(object, pev_owner, id)
        
        
        set_task(0.5, "object_update_data", object)
        client_print(0, print_chat, " object created %d" , object)
		if(!pev_valid(object)) 
		{//Проверяем сущетсвует ли, если нет
		    return PLUGIN_HANDLED //Заканчиваем. Дальше нам делать нечего
	    }
	
	    /*
        new units = get_entity_distance(id,object) // берём дистанцию между хозяином и миной
	    if(units > GMORTAR_SETDIST || g_maxgm>= GMORTAR_MAXALL || g_gm_limit[id] >= GMORTAR_MAXHAVE)  // если расстоняние более 150 , или колво макс мин больше то удаляем
	    { 
		remove_entity(object)
		// client_print(id,print_chat,"You can not set mine: Distance: %d / %f | Actived mines on ground %d / %d ",units, GMORTAR_SETDIST, g_gm_limit[id], GMORTAR_MAXHAVE )
		
	    }*/

	    else
        {
		    /// ну а если не больше 150 то выполняем этот код
            // g_maxgmortars++
            g_gm_limit[id]++
            g_gm_owner[object] = id
            
            // set_pev(object, pev_nextthink, get_gametime() + 1.0) //Создаем запуск think
            
            
            
            // set_task(2.0, "gm_attack", object )
            // set_task(2.0, gm_attack, object)
		
	    }
    }
    return PLUGIN_HANDLED
} 


public object_accept(id)
{   
    // true == complete
    g_player_accept[id] = true
}

public object_update_data(object)
{
    new owner = pev(object,pev_owner)
    if (g_player_accept[owner] == false)
    {
        client_print(0, print_chat, " settings for %d" , object)
        new iOrigin[3] //Создаем массив для хранение координат
		new iOrigin1[3] // игрока ориджэин
        new Float:velocity[3],Float:f5Angles[3]	
        velocity_by_aim(owner, 10, velocity)
        vector_to_angle(velocity, f5Angles)	
       
		get_user_origin(owner, iOrigin, 3) //Получаем координаты куда смотрит игрок
		get_user_origin(owner, iOrigin1, 0) // координаты игрока

        /*
		velocity[2] += float (get_pcvar_num(cv_angpitch))
		vector_to_angle(velocity, f5Angles)		
		f5Angles[0] += 45.0
		f5Angles[2] += 80.0
        */
		
		new Float:fOrigin[3] //Создаем массив для float коодинат
		IVecFVec(iOrigin, fOrigin) //Конвертируем координаты в дробные \ берём точку трассировки зрения
	    set_pev(object, pev_origin, fOrigin) //Присваиваем координаты точки зрения	
        set_pev(object, pev_angles, f5Angles)	// присваеваем Rotation 

        //set_pev(object, pev_health, 1.0);
	    //set_pev(object, pev_takedamage, DAMAGE_YES);
	    set_pev(object, pev_classname, g_gmcname) //Присваиваем Classname
	    set_pev(object, pev_solid, SOLID_BBOX) //Делаем его непроходимым
	    set_pev(object, pev_movetype, MOVETYPE_NONE) //Не задаем тип движения, во всяком случаи пока
	    // set_pev(object, pev_sequence, 0) //Выставляем № анимации при создании
	    // set_pev(object, pev_framerate, 1.0) //Выставляем скорость анимации
	
	    // new units = get_entity_distance(id,object) // берём дистанцию между хозяином и миной
	    // client_print(id,print_chat,"Distance to mine %d units", units) // вывод информации
        
        emit_sound(owner,CHAN_VOICE,"weapons/bazookareloadshovehome.wav",0.8,ATTN_NORM,0,PITCH_NORM + random_num(-30, -20)) // звук установки
        engfunc(EngFunc_SetModel, object, g_gmmdl) //Присваиваем модель
        engfunc(EngFunc_SetSize, object, Float:{-6.0, -6.0, -3.0}, Float:{36.0, 36.0, 45.0}) //Создаем бокс вокруг entity( для прикосновения и не только )
        set_task(0.5, "object_update_data", object)
        
    }
    else 
    {   
        emit_sound(owner,CHAN_VOICE,"weapons/bazookareloadshovehome.wav",0.8,ATTN_NORM,0,PITCH_NORM + random_num(-30, -20)) // звук установки
        return ;
    }
}